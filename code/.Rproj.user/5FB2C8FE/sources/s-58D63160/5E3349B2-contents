## sv_master.R 

# setwd("~/Dropbox/research/strategic_voting/code/")

library(here)
# getting code
source(here("utils", "general_iteration_simulation_approach.r")) 
source(here("utils", "sv.r"))


# get the CSES data 
source(here("get_cses_utility_matrices_and_weights_in_a_big_list.r")) # loading data -- takes a little while


# this loop below takes a while -- though under an hour on my machine 
ss = c(15, 30, 45, 60, 85)
lambdas = c(0, .1, .2, .3, .4, .5)

sv.result.list = list()

for(i in 1:length(cases)){
  cat("========", cases[i], "========\n")
  sv.result.list[[cases[i]]] = list()
  for(s in ss){
    cat("     s = ", s, ": ")
    this.list = list()
    this.U = big_list[[cases[i]]]$U
    these.weights = big_list[[cases[i]]]$weights
    sv.pl = sv(U = this.U, weights = these.weights, s = s)
    sv.av = sv(U = this.U, weights = these.weights, s = s, rule = "AV")
  
    # success of condorcet winner: how well does Condorcet winner do as a function of how much myopic level-1 strategic voting? 
    cw.success.pl = evaluate_success_of_CW_given_U_and_V.mat(U = this.U, V.mat = sv.pl$V.mat, V0 = sv.pl$V0, lambdas = lambdas, weights = these.weights, rule = "plurality", m = 300, M = 1000)
    cw.success.av = evaluate_success_of_CW_given_U_and_V.mat(U = this.U, V.mat = sv.av$V.mat, V0 = sv.av$V0, lambdas = lambdas, weights = these.weights, rule = "AV", m = 300, M = 1000)
    
    # interdependence: how does optimal vote of level-2 strategic voter depend on one's belief about how many level-1 strategic voters there are? 
    lambda.sv.list = list()
    for(lambda in lambdas[-1]){
      cat(".")
      pl.v.vec = lambda*ballot.props.from.vote.mat.and.weights(sv.pl$V.mat, these.weights) + (1 - lambda)*ballot.props.from.vote.mat.and.weights(sv.pl$V0, these.weights)
      av.v.vec = lambda*ballot.props.from.vote.mat.and.weights(sv.av$V.mat, these.weights) + (1 - lambda)*ballot.props.from.vote.mat.and.weights(sv.av$V0, these.weights)
      
      sv.pl.2 = sv(U = this.U, v.vec = pl.v.vec, weights = these.weights, s = s)
      sv.av.2 = sv(U = this.U, v.vec = av.v.vec, weights = these.weights, s = s, rule = "AV")
      lambda.sv.list[[paste0("lambda=", lambda)]] = list(sv.pl.2 = sv.pl.2, sv.av.2 = sv.av.2)
    }
    
    for(name in c("sv.pl", "sv.av", "cw.success.pl", "cw.success.av", "lambda.sv.list")){
      this.list[[name]] = get(name)
    }
    
    sv.result.list[[cases[i]]][[paste0("s=", s)]] = this.list
    cat("\n")
  }
}

# OK now processing the results. 


k = length(cases)

# how much info: as function of s, what proportion with a tactical vote on average (might break into vote for second, vote for third) -- just means or more info? 

# first get the data 
data.mat = matrix(NA, nrow = k, ncol = length(ss))
rownames(data.mat) = cases[1:k]
colnames(data.mat) = paste0("s=", ss)

originals = c("ABC", "ACB", "BAC", "BCA", "CAB", "CBA")
vote2s = c("BAC", "CAB", "ABC", "CBA", "ACB", "BCA")
vote3s = c("CAB", "BAC", "CBA", "ABC", "BCA", "ACB")

av2.mat = av3.mat = pl.mat = data.mat

for(i in 1:k){
  for(j in 1:length(ss)){
    s = ss[j]
    this.list = sv.result.list[[cases[i]]][[paste0("s=", s)]]
    nonsincere.pl = as.integer(this.list$sv.pl$opt.votes.sincere != this.list$sv.pl$opt.votes.strategic)
    pl.mat[i,j] = sum(this.list$sv.pl$weights[!is.na(nonsincere.pl) & nonsincere.pl])/sum(this.list$sv.pl$weights[!is.na(nonsincere.pl)]) 
    sincere.av = this.list$sv.av$opt.votes.sincere
    strategic.av = this.list$sv.av$opt.votes.strategic
    vote.2.av = vote.3.av = sincere.av
    for(l in 1:length(originals)){
      vote.2.av[sincere.av == originals[l]] = vote2s[l]
      vote.3.av[sincere.av == originals[l]] = vote3s[l]
    }
    av2.mat[i,j] = sum(this.list$sv.av$weights[!is.na(strategic.av) & strategic.av == vote.2.av])/sum(this.list$sv.av$weights[!is.na(strategic.av)])
    av3.mat[i,j] = sum(this.list$sv.av$weights[!is.na(strategic.av) & strategic.av == vote.3.av])/sum(this.list$sv.av$weights[!is.na(strategic.av)])
  }
}

# now to plot it -- maybe just traces and means for now?

fig.date = "20181029"

fig.loc = here("..", "output", "figs", fig.date) # paste0("~/Dropbox/research/strategic_voting/output/figs/", fig.date, "/")

pdf(paste0(fig.loc, "tactical_incentives_as_fn_of_s_rcv_and_plurality.pdf"), width = 6, height = 5)
par(mfrow = c(1,1))

plot(c(10, 90), c(0, .5), type = "n", xlab = "Precision of beliefs (s)", ylab = "Proportion with positive tactical incentive", axes = F)
axis(1, at = ss, labels = ss); axis(2) 
for(i in 1:nrow(av2.mat)){
  lines(ss, pl.mat[i,], col = rgb(.6, .6, 1, alpha = .2))
  lines(ss, av2.mat[i,], col = rgb(1, .8, .6, alpha = .2))
  lines(ss, av3.mat[i,], col = rgb(1, .6, .6, alpha = .2))
}
pl.means = apply(pl.mat, 2, mean, na.rm = T)
lines(ss, pl.means, lwd = 3, col = "blue")
av2.means = apply(av2.mat, 2, mean, na.rm = T)
lines(ss, av2.means, lwd = 3, col = "orange")
av3.means = apply(av3.mat, 2, mean, na.rm = T)
lines(ss, av3.means, lwd = 3, col = "red")
legend("topleft", lwd = c(3,3,3), col = c("orange", "red", "blue"), legend = c("RCV: second choice first", "RCV: third choice first", "Plurality: second choice first"))
# text(x = rep(ss[length(ss)], 3), y = c(pl.means[length(ss)], av2.means[length(ss)], av3.means[length(ss)]), pos = 3, labels = c("Plurality", "RCV: vote for\nsecond choice", "RCV: vote for\nthird choice"))
dev.off()


## frequency of positive incentive via scatterplots 


for(s in ss){
  pdf(paste0(fig.loc, "proportion_positive_tactical_incentives_rcv_and_plurality_s_", s, ".pdf"), width = 3, height = 6)
  par(mfrow = c(1,1), mar = c(4,4,0,1))
  plot(c(0, .25), c(0, .7), type = "n", xlab = "Plurality: proportion with positive tactical incentive", ylab = "RCV: proportion with positive tactical incentive", axes = F) #  main = paste0("s = ", s))
  axis(1); axis(2) 
  abline(a = 0, b = 1, col = "gray")
  prop.mat = matrix(NA, nrow = k, ncol = 2)
  for(i in 1:k){
    this.list = sv.result.list[[cases[i]]][[paste0("s=", s)]]
    prop.av = sum(this.list$sv.av$weights[!is.na(this.list$sv.av$tau) & this.list$sv.av$tau > 0])/sum(this.list$sv.av$weights[!is.na(this.list$sv.av$tau)])
    prop.pl = sum(this.list$sv.pl$weights[!is.na(this.list$sv.pl$tau) & this.list$sv.pl$tau > 0])/sum(this.list$sv.pl$weights[!is.na(this.list$sv.pl$tau)])
    points(prop.pl, prop.av, pch = 19, col = rgb(.4, .4, .4, alpha = .5))
    prop.mat[i, ] =  c(prop.pl, prop.av)
  }
  # abline(lm(prop.mat[,2] ~ prop.mat[,1]), col = "red") really no reason to expect a linear relationship
  dev.off()
}

## magnitude of incentive via qqplots 

for(s in ss){
  big.xs = big.ys = c()
  pdf(paste0(fig.loc, "qq_tactical_incentives_rcv_and_plurality_s_", s, ".pdf"), width = 5, height = 5)
  par(mfrow = c(1,1), mar = c(4,4,0,1))
  plot(c(-35, 25), c(-35, 25), type = "n", xlab = "Tactical incentive in plurality", ylab = "Tactical incentive in RCV", axes = F) #  main = paste0("s = ", s))
  axis(1, at = c(-1000, 0, 1000)); axis(2, at = c(-1000, 0, 1000))
  abline(a = 0, b = 1, col = "gray")
  abline(v = 0, lty = 3, col = "gray")
  abline(h = 0, lty = 3, col = "gray")
  for(i in 1:k){
    this.list = sv.result.list[[cases[i]]][[paste0("s=", s)]]
    qq = qqplot(this.list[["sv.pl"]]$tau, this.list[["sv.av"]]$tau, plot.it = F) # ignoring weights here. 
    lines(qq$x, qq$y, col = rgb(.4, .4, .4, alpha = .3))
    big.xs = c(big.xs, qq$x)
    big.ys = c(big.ys, qq$y)
  }
  big.qq = qqplot(big.xs, big.ys, plot.it = F) # ignoring weights here. 
  lines(big.qq$x, big.qq$y, col = "blue", lwd = 3)
  
  # now we want a ksmooth here
#  big.xs.o = sort(big.xs)
#  big.ys.o = big.ys[order(big.xs)]
#  lines(ksmooth(big.xs.o, big.ys.o, bandwidth = 3), lwd = 3, col = "blue") # this is very computationally intensive -- shouldn't be so hard! 
  dev.off()
}

## ex ante relative probability of paradoxes (conditional on being pivotal). comparison with wasted vote in plurality. 

for(s in ss){
  pdf(paste0(fig.loc, "paradoxes_etc_rcv_and_plurality_s_", s, ".pdf"), width = 5, height = 5)
  par(mfrow = c(1,1), mar = c(4,6,0,1))
  plot(c(0, 1/3), c(0, 1/3), type = "n", xlab = "Plurality: Pr(wasted vote | pivotal, sincere)", ylab = "RCV: Pr(no-show paradox | pivotal, sincere) and\nPr(monotonicity violation | pivotal, sincere)", axes = F) #  main = paste0("s = ", s))
  axis(1); axis(2) 
  abline(a = 0, b = 1, col = "gray")
  prop.mat = matrix(NA, nrow = k, ncol = 3)
  colnames(prop.mat) = c("wv", "nsp", "nmn")
  for(i in 1:k){
    this.list = sv.result.list[[cases[i]]][[paste0("s=", s)]]
    wv = plurality_wasted_vote_from_sv_object(this.list$sv.pl)
    nsp_nm = no_show_non_mon_from_sv_object(this.list$sv.av)
    this.row = c(wv$avg.wv.prob/wv$prob.sum, nsp_nm$avg.ns.prob/nsp_nm$prob.sum, (nsp_nm$avg.nm1.prob + nsp_nm$avg.nm2.prob)/nsp_nm$prob.sum)
    points(this.row[1], this.row[2], pch = 19, col = rgb(.4, .4, .8, alpha = .5))
    points(this.row[1], this.row[3], pch = 19, col = rgb(.8, .4, .4, alpha = .5))
    prop.mat[i, ] =  this.row
  }
  prop.mat = as.data.frame(prop.mat)
  nsp.lm = lm(nsp ~ wv, data = prop.mat)
  nmn.lm = lm(nmn ~ wv, data = prop.mat)
  abline(nsp.lm, col = "blue")
  abline(nmn.lm, col = "red")
  text(x = .3, y = predict(nsp.lm, newdata = data.frame("wv" = .3)), pos = 1, labels = "No-show\nparadox", cex = .7)
  text(x = .3, y = predict(nmn.lm, newdata = data.frame("wv" = .3)), pos = 3, labels = "Monotonicity\n failure", cex = .7)
  dev.off()
}

# success of condorcet winner
# put together the data 

cw.data = matrix(NA, nrow = 2*length(ss)*k, ncol = length(lambdas))
cw.case = cw.rule = cw.s = rep(NA, 2*length(ss)*k)
colnames(cw.data) = paste0("lambda_", lambdas)

this.row = 0
for(i in 1:k){
  this.list = sv.result.list[[cases[i]]]
  for(j in 1:length(ss)){
    s = ss[j]
    
    this.row = this.row + 1
    pl.part = this.list[[paste0("s=", s)]]$cw.success.pl
    cw.data[this.row, ] = pl.part
    cw.case[this.row] = cases[i]
    cw.rule[this.row] = "plurality"
    cw.s[this.row] = s
    
    this.row = this.row + 1
    av.part = this.list[[paste0("s=", s)]]$cw.success.av
    cw.data[this.row, ] = av.part
    cw.case[this.row] = cases[i]
    cw.rule[this.row] = "AV"
    cw.s[this.row] = s
  }
}

cw.df = as.data.frame(cw.data)
cw.df$case = cw.case
cw.df$rule = cw.rule
cw.df$s = cw.s
  
# and then plot it 

for(s in ss){
  pl.cw.success.mat = cw.df[cw.df$rule == "plurality" & cw.df$s == s, 1:length(lambdas)]
  av.cw.success.mat = cw.df[cw.df$rule == "AV" & cw.df$s == s, 1:length(lambdas)]
  
  pdf(paste0(fig.loc, "successof_cw_s_", s, ".pdf"), width = 5, height = 5)
  par(mfrow = c(1,1), mar = c(5,4,1,1))
  space = 0
  plot(c(1, ncol(pl.cw.success.mat)) + c(-space, space), c(.6,1), type = "n", xlab = "Proportion level-1 strategic voters\nobserving poll of sincere preferences", ylab = "Condorcet winner's probability of victory", axes = F)
  abline(h = seq(0, 1, by = .1), col = rgb(.2, .2, .2, alpha = .8))
  for(j in 1:nrow(pl.cw.success.mat)){
    lines(1:ncol(av.cw.success.mat), av.cw.success.mat[j,], col = rgb(.7, .7, 1, alpha = .2))
    lines(1:ncol(pl.cw.success.mat), pl.cw.success.mat[j,], col = rgb(1, 3/4, 1/2, alpha = .2))
  }
  av.means = apply(av.cw.success.mat, 2, mean, na.rm = T)
  pl.means = apply(pl.cw.success.mat, 2, mean, na.rm = T)
  lines(1:ncol(pl.cw.success.mat), av.means, col = "blue", lwd = 2)
  lines(1:ncol(pl.cw.success.mat), pl.means, col = "orange", lwd = 2)
  axis(2)
  axis(1, at = 1:ncol(pl.cw.success.mat), labels = lambdas)
  text(c(2, 1.5), c(av.means[2], mean(c(pl.means[1], pl.means[2]))), labels = c("RCV", "plurality"), pos = c(3, 3))
  
  dev.off()
  
}


## ok now strategic interdependence 
# let's use what I have already on this.
# what I showed there was: 
### 1) as a function of lambda, does level-2 strategic voter want to vote sincerely or not? 
### 2) as a function of lambda, does level-2 strategic vote differ from level-1 strategic vote?
## let's reacquaint ourselves with what we stored. 

# again, let's extract the data first. 
# we want for (1) proportion whose optimal vote is non-sincere as function of lambda
# by case and s

id.mat = matrix(NA, nrow = 2*k*length(ss), ncol = length(lambdas))
colnames(id.mat) = paste0("lambda=", lambdas)
id.cases = id.rules = id.ss = rep(NA, k*length(ss))


row.number = 0
for(i in 1:k){
  for(j in 1:length(ss)){
    row.number = row.number + 1
    
    this.obj = sv.result.list[[cases[i]]][[paste0("s=", ss[j])]][["sv.pl"]]
    pl.sincere.votes = this.obj$opt.votes.sincere
    
    this.vec = c(sum(this.obj$weights[!is.na(this.obj$opt.votes.strategic) & pl.sincere.votes != this.obj$opt.votes.strategic], na.rm = T)/sum(this.obj$weights[!is.na(this.obj$opt.votes.strategic)], na.rm = T))
    
    for(l in 2:length(lambdas)){
      this.obj = sv.result.list[[cases[i]]][[paste0("s=", ss[j])]][["lambda.sv.list"]][[paste0("lambda=", lambdas[l])]][["sv.pl.2"]]
      this.prop = sum(this.obj$weights[!is.na(this.obj$opt.votes.strategic) & pl.sincere.votes != this.obj$opt.votes.strategic], na.rm = T)/sum(this.obj$weights[!is.na(this.obj$opt.votes.strategic)], na.rm = T)
      this.vec = c(this.vec, this.prop)
    }
    id.mat[row.number,] = this.vec
    id.cases[row.number] = cases[i]
    id.ss[row.number] = ss[j]
    id.rules[row.number] = "plurality"

    row.number = row.number + 1
    this.obj = sv.result.list[[cases[i]]][[paste0("s=", ss[j])]][["sv.av"]]
    av.sincere.votes = this.obj$opt.votes.sincere
    
    this.vec = c(sum(this.obj$weights[!is.na(this.obj$opt.votes.strategic) & av.sincere.votes != this.obj$opt.votes.strategic], na.rm = T)/sum(this.obj$weights[!is.na(this.obj$opt.votes.strategic)], na.rm = T))
        
    for(l in 2:length(lambdas)){
      this.obj = sv.result.list[[cases[i]]][[paste0("s=", ss[j])]][["lambda.sv.list"]][[paste0("lambda=", lambdas[l])]][["sv.av.2"]]
      this.prop = sum(this.obj$weights[!is.na(this.obj$opt.votes.strategic) & av.sincere.votes != this.obj$opt.votes.strategic], na.rm = T)/sum(this.obj$weights[!is.na(this.obj$opt.votes.strategic)], na.rm = T)
      this.vec = c(this.vec, this.prop)
    }
    id.mat[row.number,] = this.vec
    id.cases[row.number] = cases[i]
    id.ss[row.number] = ss[j]
    id.rules[row.number] = "AV"
    
  }
}


id.df = as.data.frame(id.mat)
id.df$case = id.cases
id.df$rule = id.rules
id.df$s = id.ss

# now the plots 


for(s in ss){
  pl.id.mat = id.df[id.df$rule == "plurality" & id.df$s == s, 1:length(lambdas)]
  av.id.mat = id.df[id.df$rule == "AV" & id.df$s == s, 1:length(lambdas)]
  
  pdf(paste0(fig.loc, "proportion_tactical_vote_optimal_as_function_of_lambda_s_", s, ".pdf"), width = 5, height = 5)
  par(mfrow = c(1,1), mar = c(5,4,1,1))
  space = 0
  plot(c(1, ncol(pl.id.mat)) + c(-space, space), c(0, .6), type = "n", xlab = "Perceived proportion level-1 strategic", ylab = "Proportion whose level-2 strategic vote is non-sincere", axes = F)
  for(j in 1:nrow(pl.id.mat)){
    lines(1:ncol(av.id.mat), av.id.mat[j,], col = rgb(.7, .7, 1, alpha = .2))
    lines(1:ncol(pl.id.mat), pl.id.mat[j,], col = rgb(1, 3/4, 1/2, alpha = .2))
  }
  av.means = apply(av.id.mat, 2, mean, na.rm = T)
  pl.means = apply(pl.id.mat, 2, mean, na.rm = T)
  lines(1:ncol(pl.id.mat), av.means, col = "blue", lwd = 2)
  lines(1:ncol(pl.id.mat), pl.means, col = "orange", lwd = 2)
  axis(2)
  axis(1, at = 1:ncol(pl.id.mat), labels = lambdas)
  text(c(3.5, 3.5), c(mean(c(av.means[3], av.means[4])), mean(c(pl.means[3], pl.means[4]))), labels = c("RCV", "plurality"), pos = c(1, 3))
  
  dev.off()
  
}

# now for the other question: much of the same code 
### 2) as a function of lambda, does level-2 strategic vote differ from level-1 strategic vote?


id.mat = matrix(NA, nrow = 2*k*length(ss), ncol = length(lambdas))
colnames(id.mat) = paste0("lambda=", lambdas)
id.cases = id.rules = id.ss = rep(NA, k*length(ss))


row.number = 0
for(i in 1:k){
  for(j in 1:length(ss)){
    row.number = row.number + 1
    
    this.obj = sv.result.list[[cases[i]]][[paste0("s=", ss[j])]][["sv.pl"]]
    pl.strategic.votes = this.obj$opt.votes.strategic
    
    this.vec = c(sum(this.obj$weights[!is.na(this.obj$opt.votes.strategic) & pl.strategic.votes != this.obj$opt.votes.strategic], na.rm = T)/sum(this.obj$weights[!is.na(this.obj$opt.votes.strategic)], na.rm = T))
    
    for(l in 2:length(lambdas)){
      this.obj = sv.result.list[[cases[i]]][[paste0("s=", ss[j])]][["lambda.sv.list"]][[paste0("lambda=", lambdas[l])]][["sv.pl.2"]]
      this.prop = sum(this.obj$weights[!is.na(this.obj$opt.votes.strategic) & pl.strategic.votes != this.obj$opt.votes.strategic], na.rm = T)/sum(this.obj$weights[!is.na(this.obj$opt.votes.strategic)], na.rm = T)
      this.vec = c(this.vec, this.prop)
    }
    id.mat[row.number,] = this.vec
    id.cases[row.number] = cases[i]
    id.ss[row.number] = ss[j]
    id.rules[row.number] = "plurality"
    
    row.number = row.number + 1
    this.obj = sv.result.list[[cases[i]]][[paste0("s=", ss[j])]][["sv.av"]]
    av.strategic.votes = this.obj$opt.votes.strategic
    
    this.vec = c(sum(this.obj$weights[!is.na(this.obj$opt.votes.strategic) & av.strategic.votes != this.obj$opt.votes.strategic], na.rm = T)/sum(this.obj$weights[!is.na(this.obj$opt.votes.strategic)], na.rm = T))
    
    for(l in 2:length(lambdas)){
      this.obj = sv.result.list[[cases[i]]][[paste0("s=", ss[j])]][["lambda.sv.list"]][[paste0("lambda=", lambdas[l])]][["sv.av.2"]]
      this.prop = sum(this.obj$weights[!is.na(this.obj$opt.votes.strategic) & av.strategic.votes != this.obj$opt.votes.strategic], na.rm = T)/sum(this.obj$weights[!is.na(this.obj$opt.votes.strategic)], na.rm = T)
      this.vec = c(this.vec, this.prop)
    }
    id.mat[row.number,] = this.vec
    id.cases[row.number] = cases[i]
    id.ss[row.number] = ss[j]
    id.rules[row.number] = "AV"
    
  }
}


id.df = as.data.frame(id.mat)
id.df$case = id.cases
id.df$rule = id.rules
id.df$s = id.ss

# now the plots 


for(s in ss){
  pl.id.mat = id.df[id.df$rule == "plurality" & id.df$s == s, 1:length(lambdas)]
  av.id.mat = id.df[id.df$rule == "AV" & id.df$s == s, 1:length(lambdas)]
  
  pdf(paste0(fig.loc, "proportion_level_2_vote_different_from_level_1_vote_as_function_of_lambda_s_", s, ".pdf"), width = 5, height = 5)
  par(mfrow = c(1,1), mar = c(5,6,1,1))
  space = 0
  plot(c(1, ncol(pl.id.mat)) + c(-space, space), c(0, .6), type = "n", xlab = "Perceived proportion level-1 strategic", ylab = "Proportion whose level-2 strategic vote is\ndifferent from level-1 strategic vote", axes = F)
  for(j in 1:nrow(pl.id.mat)){
    lines(1:ncol(av.id.mat), av.id.mat[j,], col = rgb(.7, .7, 1, alpha = .2))
    lines(1:ncol(pl.id.mat), pl.id.mat[j,], col = rgb(1, 3/4, 1/2, alpha = .2))
  }
  av.means = apply(av.id.mat, 2, mean, na.rm = T)
  pl.means = apply(pl.id.mat, 2, mean, na.rm = T)
  lines(1:ncol(pl.id.mat), av.means, col = "blue", lwd = 2)
  lines(1:ncol(pl.id.mat), pl.means, col = "orange", lwd = 2)
  axis(2)
  axis(1, at = 1:ncol(pl.id.mat), labels = lambdas)
  text(c(4, 4.5), c(av.means[4], mean(c(pl.means[4], pl.means[5]))), labels = c("RCV", "plurality"), pos = c(3, 3))
  
  dev.off()
  
}



