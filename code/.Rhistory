summarize(mean(value)))
names(prop_df_agg)[3] <- "value"
aus_freq <- ggplot(prop_df_long, aes(x = s, y = value)) +
geom_line(aes(colour = variable, group = interaction(const, variable)), alpha = 0.05) +
geom_line(data = prop_df_agg, aes(colour = variable, group = variable, x = s, y = value),
size = 2) +
labs(x = "Information (s)",
y = "Proportion of voters in AES casting ballot type",
colour = "Sincere pref. as first on ballot") +
theme_bw() +
scale_x_continuous(expand = c(0, 0)) +
scale_y_continuous(expand = c(0.1, 0), limits = c(0, 0.5)) +
theme(legend.position = "bottom", legend.direction = "vertical")
gg_path <- here("../output/figures/australia_sv_freq.pdf")
ggsave(gg_path, height = 5, width = 4)
# (2) Total strategic incentives
prop_df$inc_rcv <- prop_df$RCV_second + prop_df$RCV_third
prop_df$inc_plur <- prop_df$plur_second
aus_inc <- ggplot(prop_df, aes(x = inc_plur, y = inc_rcv)) +
geom_point() +
geom_abline(slope = 1, intercept = 0) +
facet_wrap(~ s) +
theme_bw() +
scale_x_continuous(limits = c(0, 0.7), expand = c(0, 0)) +
scale_y_continuous(limits = c(0, 0.7), expand = c(0, 0)) +
labs(x = "Proportion of AES respondents with positive SI under Plurality",
y = "Proportion of AES respondents with positive SI under RCV")
gg_path2 <- here("../output/figures/australia_sv_prop.pdf")
ggsave(gg_path2, aus_inc, width = 5, height = 5)
aus_inc
# Check out who the outliers are
inc90 <- prop_df[prop_df$s == 90]
# Check out who the outliers are
inc90 <- prop_df[prop_df$s == 90, ]
which(inc90$inc_plur > 0.2)
simplex_df <- data.frame(A = const_bp[, 1] + const_bp[, 2] + const_bp[, 7],
B = const_bp[, 3] + const_bp[, 4] + const_bp[, 8],
C = const_bp[, 5] + const_bp[, 6] + const_bp[, 9])
simplex_df <- data.frame(A = const_bp[, 2] + const_bp[, 3] + const_bp[, 8],
B = const_bp[, 4] + const_bp[, 5] + const_bp[, 9],
C = const_bp[, 6] + const_bp[, 7] + const_bp[, 10])
library(ggtern)
ggtern(simplex_df, aes(A, B, C))
ggtern(simplex_df, aes(A, B, C)) +
geom_point()
ggtern(simplex_df[outliers, ], aes(A, B, C)) +
geom_point()
outliers <- which(inc90$inc_plur > 0.2)
ggtern(simplex_df[outliers, ], aes(A, B, C)) +
geom_point()
ggtern(simplex_df[outliers, ], aes(A, B, C)) +
geom_point() +
geom_point(simplex_df[-outliers, ], aes(A, B, C), colour = "light grey")
ggtern(simplex_df[outliers, ], aes(A, B, C)) +
geom_point() +
geom_point(data = simplex_df[-outliers, ], aes(A, B, C), colour = "light grey")
ggtern(simplex_df[outliers, ], aes(A, B, C)) +
geom_point() +
geom_point(data = simplex_df, aes(A, B, C), colour = "light grey")
ggtern(simplex_df[outliers, ], aes(A, B, C)) +
geom_point(data = simplex_df, aes(A, B, C), colour = "light grey") +
geom_point()
# Function: take ballot profile, DF of utilities, and returns vector of tactical incentives at different
return_sv_tau <- function(v_vec, util_df, s_breaks){
v_vec <- as.numeric(v_vec) / sum(v_vec)
sin_vec <- apply(util_df, 1, sin_vote_scalar)
# RCV part
p_list <- lapply(s_breaks, function(x) av.pivotal.event.probs.general(v_vec, rep(x, 4)))
eu_list <- lapply(p_list, function(x) opt_vote(util_df, x, type = "rcv"))
tau_list <- lapply(eu_list, function(x) calculate_tau(x, sin_vec))
# Plurality part
# Do the same for plurality
sin_vec_plur <- sin_vote_plur_transform(sin_vec)
v_vec_three <- c(v_vec[1] + v_vec[2] + v_vec[7], v_vec[3] + v_vec[4] + v_vec[8], v_vec[5] + v_vec[6] + v_vec[9])
p_list_plur <- lapply(s_breaks, function(x) plurality.pivotal.probabilities(v_vec_three, x))
eu_list_plur <- lapply(p_list_plur, function(x) opt_vote(util_df, x, type = "plur"))
tau_list_plur <- lapply(eu_list_plur, function(x) calculate_tau(x, sin_vec_plur))
# Render optimal votes
opt_list <- lapply(eu_list, function(x) opt_vote_scalar(x))
opt_vec <- unlist(opt_list)
opt_list_plur <- lapply(eu_list_plur, function(x) opt_vote_scalar(x))
opt_vec_plur <- unlist(opt_list_plur)
# Merge into one big data-frame
n <- length(s_breaks)
# return(tau_list[[1]][1:3])
tau_vec_rcv <- unlist(tau_list)
# return(tau_vec_rcv)
tau_vec_plur <- unlist(tau_list_plur)
out_df <- as.data.frame(cbind(rep(sin_vec, n), rep(sin_vec_plur, n), tau_vec_rcv, tau_vec_plur, opt_vec, opt_vec_plur, rep(unlist(s_breaks), each = nrow(util_df))))
#out_df <- apply(out_df, 2, function(x) unlist(x))
names(out_df) <- c("sin_rcv", "sin_plur", "tau_rcv", "tau_plur", "opt_rcv", "opt_plur", "s")
return(out_df)
}
library(pbapply)
pbapply(const_bp[, 2:10], 1, function(x) return_sv_tau(as.numeric(x), aes_utils_raw, s_list))
mega_tau_list_2 <- pbapply(const_bp[, 2:10], 1, function(x) return_sv_tau(as.numeric(x), aes_utils_raw, s_list))
mega_tau_list_2 <- pbapply(const_bp[, 2:10], 1, function(x) return_sv_tau(as.numeric(x), aes_utils_raw, s_list))
mega_tau_list_2[[1]]
mega_tau_list <- mega_tau_list_2
for(i in nrow(const_bp)){
mega_tau_list_2[[i]]$const <- const_bp[i, 1]
}
mega_tau_list[[1]]
mega_tau_list[[i]]$const <- const_bp[i, 1]
mega_tau_list[[1]]
for(i in 1:nrow(const_bp)){
mega_tau_list[[i]]$const <- const_bp[i, 1]
}
for(i in 1:nrow(const_bp)){
mega_tau_list[[i]]$const <- const_bp[i, 1]
}
mega_tau_list[[1]]
# save as separate object to avoid having to run it every time.
save(mega_tau_list, file = here("../output/mega_tau_list_trunc_plur.Rdata"))
load(here("../output/mega_tau_list_trunc_plur.Rdata"))
# (1) levels of strategic voting
prop_list <- lapply(mega_tau_list, function(x) try(sv_prop(x)))
prop_df <- as.data.frame(do.call(rbind, prop_list))
prop_df$const <- rep(c(const_bp$district), each = length(s_list))
prop_df$s <- rep(unlist(s_list), nrow(const_bp))
prop_df[, 1:5] <- prop_df[, 1:5] / 1133
prop_df <- prop_df[, c(2, 3, 5, 6, 7)]
names(prop_df)[1:3] <- c("RCV_second", "RCV_third", "plur_second")
prop_df_long <- melt(prop_df, id.vars = c("const", "s"))
prop_df_agg <- as.data.frame(prop_df_long %>%
group_by(variable, s) %>%
summarize(mean(value)))
names(prop_df_agg)[3] <- "value"
aus_freq <- ggplot(prop_df_long, aes(x = s, y = value)) +
geom_line(aes(colour = variable, group = interaction(const, variable)), alpha = 0.05) +
geom_line(data = prop_df_agg, aes(colour = variable, group = variable, x = s, y = value),
size = 2) +
labs(x = "Information (s)",
y = "Proportion of voters in AES casting ballot type",
colour = "Sincere pref. as first on ballot") +
theme_bw() +
scale_x_continuous(expand = c(0, 0)) +
scale_y_continuous(expand = c(0.1, 0), limits = c(0, 0.5)) +
theme(legend.position = "bottom", legend.direction = "vertical")
aus_freq
gg_path <- here("../output/figures/australia_sv_freq.pdf")
ggsave(gg_path, height = 5, width = 4)
prop_df$inc_rcv <- prop_df$RCV_second + prop_df$RCV_third
prop_df$inc_plur <- prop_df$plur_second
aus_inc <- ggplot(prop_df, aes(x = inc_plur, y = inc_rcv)) +
geom_point() +
geom_abline(slope = 1, intercept = 0) +
facet_wrap(~ s) +
theme_bw() +
scale_x_continuous(limits = c(0, 0.7), expand = c(0, 0)) +
scale_y_continuous(limits = c(0, 0.7), expand = c(0, 0)) +
labs(x = "Proportion of AES respondents with positive SI under Plurality",
y = "Proportion of AES respondents with positive SI under RCV")
gg_path2 <- here("../output/figures/australia_sv_prop.pdf")
aus_inc
# This still seems weird. What is happening here?
inc60 <- prop_df[prop_df$s == 60]
# This still seems weird. What is happening here?
inc60 <- prop_df[prop_df$s == 60, ]
View(inc60)
mega_tau_list[[1]][mega_tau_list[[1]]$s == 60, ]
apply(aes_utils_raw, 1, function(x) max(x) == x[1])
sum(apply(aes_utils_raw, 1, function(x) max(x) == x[1])) / nrow(aes_utils_raw)
qq_mega_list <- lapply(mega_tau_list, function(x) qq_function_two(x, aes_utils_raw))
qq_mega_df <- as.data.frame(do.call(rbind, qq_mega_list))
qq_mega_df$const <- rep(c(const_bp$district), each = nrow(aes_utils_raw) * length(unlist(s_list)))
qq_mega_by_s <- split(qq_mega_df, qq_mega_df$s)
qq_agg <- lapply(qq_mega_by_s, function(z) as.data.frame(qqplot(x = z$x, y = z$y, plot.it = FALSE)))
qq_agg_df <- as.data.frame(do.call(rbind, qq_agg))
qq_agg_df$s <- rep(unlist(s_list), each = nrow(aes_utils_raw) * nrow(const_bp))
aus_qq <- ggplot(qq_mega_df, aes(x = x, y = y)) +
geom_line(aes(x = x, y = y, group = const), alpha = 0.1) +
geom_line(data = qq_agg_df, aes(x = x, y = y), colour = "red", lwd = 2) +
geom_abline(intercept = 0, slope = 1, linetype = "dotted", colour = "blue") +
theme_bw()  +
facet_wrap(vars(s)) +
xlim(-30, 30) + ylim(-30, 30)
aus_qq
ggsave(here("../output/figures/australia_sv_qq.pdf"), aus_qq, width = 6, height = 6)
gg_path2 <- here("../output/figures/australia_sv_prop.pdf")
ggsave(gg_path2, aus_inc, width = 5, height = 5)
# Non-monotonicity under AV
nonmon_list <- c()
s <- 15
for(i in 1:nrow(const_bp)){
print(i)
v_vec <- as.numeric(const_bp[i, 2:10] / sum(const_bp[i, 2:10]))
pprobs <- av.pivotal.event.probs.general(v_vec, rep(s, 4))
nonmon_list[[i]] <- non_monoton(mega_tau_list[[i]][mega_tau_list[[i]]$s == s, ], pprobs)
}
# Wasted vote under Plurality
# need to decide what to do with trunc in plurality.
wasted_list <- c()
for(i in 1:nrow(const_bp)){
print(i)
v_vec <- as.numeric(const_bp[i, 2:10] / sum(const_bp[i, 2:10]))
v_vec_three <- c(v_vec[1] + v_vec[2] + v_vec[7], v_vec[3] + v_vec[4] + v_vec[8], v_vec[5] + v_vec[6] + v_vec[9])
pprobs <- plurality.pivotal.probabilities(v_vec_three, s)
wasted_list[[i]] <- wasted_vote(mega_tau_list[[i]][mega_tau_list[[i]]$s == s, ], pprobs)
}
paradox_df <- matrix(NA, ncol = 3, nrow = nrow(const_bp))
for(i in 1:nrow(const_bp)){
no_show <- nonmon_list[[i]]$no_show / nonmon_list[[i]]$total
nonmon <- (nonmon_list[[i]]$nonmon1 + nonmon_list[[i]]$nonmon2) / nonmon_list[[i]]$total
wasted <- wasted_list[[i]]$wasted / wasted_list[[i]]$total
paradox_df[i, ] <- c(no_show, nonmon, wasted)
}
paradox_df <- as.data.frame(paradox_df)
names(paradox_df) <- c("no_show", "nonmon", "wasted")
ggplot(paradox_df, aes(x = wasted)) +
geom_point(aes(y = no_show, colour = "No-show"), size = 1.5, alpha = 0.2) +
geom_point(aes(y = nonmon, colour = "Non-mon"), size = 1.5, alpha = 0.2) +
geom_abline(intercept = 0, slope = 1, lty = "dotted") +
geom_smooth(method = "loess", aes(y = no_show), colour = "blue") +
geom_smooth(method = "loess", aes(y = nonmon), colour = "red") +
xlim(0, 0.4) + ylim(0, 0.4) +
labs(x = "Pr(Wasted Vote, Plurality)", y = "Pr(Voting Paradox, RCV)", colour = "Paradox type") +
scale_colour_manual(breaks = c("No-show", "Non-mon"), values = c("No-show" = "blue", "Non-mon" = "red")) +
theme_bw() +
theme(legend.position = "bottom", legend.direction = "horizontal")
ggsave(here("../output/figures/paradoxes_aus.pdf"), width = 4, height = 4)
# Set s = 80
mega_tau_fixed_s <- lapply(mega_tau_list, function(x) x[x$s == 85, ])
# Run loop over constituencies. This will take a long time...
inter_df <- list()
lambda_list <- as.list(seq(0, 0.5, 0.05))
for(i in 1:nrow(const_bp)){
print(i)
v_vec <- as.numeric(const_bp[i, 2:10]) / sum(as.numeric(const_bp[i, 2:10]))
tau <- mega_tau_fixed_s[[i]]
const_props <- level_two_props(v_vec, lambda_list, aes_utils_raw, tau, list(80))
#const_props$const <- const_bp[i, 1]
inter_df[[i]] <- const_props
}
save(inter_df, file = here("../output/interdependence.Rdata"))
inter_df_full <- as.data.frame(do.call(rbind, inter_df))
inter_df_full$const <- rep(const_bp$district, each = length(lambda_list))
l1_plot <- ggplot(inter_df_full, aes(x = lambda, group = const)) +
geom_line(aes(y = L1RCV), colour = "blue", alpha = 0.25) +
geom_line(aes(y = L1PLUR), colour = "orange", alpha = 0.25) +
theme_bw()
l0_plot <- ggplot(inter_df_full, aes(x = lambda, group = const)) +
geom_line(aes(y = L0RCV), colour = "blue", alpha = 0.25) +
geom_line(aes(y = L0PLUR), colour = "orange", alpha = 0.25) +
theme_bw()
l1_plot
l0_plot
l1_plot <- ggplot(inter_df_full, aes(x = lambda, group = const)) +
geom_line(aes(y = L1RCV), colour = "blue", alpha = 0.25) +
geom_line(aes(y = L1PLUR), colour = "orange", alpha = 0.25) +
theme_bw()
ggsave(here("../output/figures/level1_diff.pdf"))
l0_plot <- ggplot(inter_df_full, aes(x = lambda, group = const)) +
geom_line(aes(y = L0RCV), colour = "blue", alpha = 0.25) +
geom_line(aes(y = L0PLUR), colour = "orange", alpha = 0.25) +
theme_bw()
ggsave(here("../output/figures/level0_diff.pdf"))
### DEPENDENCIES
library(here)
library()
source(here("utils/functions.r"))
# Load CSES data:
load(here("../output/cses_big_list_2.RData"))
remove_nas <- function(x){
mat <- cbind(x$U, x$weights)
mat <- na.omit(mat)
return(list(U = mat[, 1:3], weights = as.numeric(mat[, 4])))
}
create_v_vec <- function(x){
x$U <- x$U + runif(nrow(x$U) * ncol(x$U), min = 0, max = 0.001)
sin_vote <- as.numeric(apply(x$U, 1, function(x) sin_vote_scalar(x)))
num_list <- c(1:6)
sin_df <- (sapply(num_list, function(x) as.numeric(sin_vote == x)))
sin_df <- sin_df * x$weights
sin_vec <- colSums(sin_df)
return(sin_vec / sum(sin_vec))
}
# Create list with v_vecs from CSES utility dfs:
big_list_na_omit <- lapply(big_list, function(x) remove_nas(x))
sin_vote_list <- lapply(big_list_na_omit, function(x) sincere.vote.mat.from.U(x$U, rule = "AV"))
v_vec_list <- list()
for(i in 1:length(sin_vote_list)){
weights <- big_list_na_omit[[i]]$weights
v_vec <- ballot.props.from.vote.mat.and.weights(sin_vote_list[[i]], weights)
big_list_na_omit[[i]]$v_vec <- as.numeric(v_vec)
}
source(here("utils/functions.r"))
# Load CSES data:
load(here("../output/cses_big_list_2.RData"))
remove_nas <- function(x){
mat <- cbind(x$U, x$weights)
mat <- na.omit(mat)
return(list(U = mat[, 1:3], weights = as.numeric(mat[, 4])))
}
create_v_vec <- function(x){
x$U <- x$U + runif(nrow(x$U) * ncol(x$U), min = 0, max = 0.001)
sin_vote <- as.numeric(apply(x$U, 1, function(x) sin_vote_scalar(x)))
num_list <- c(1:6)
sin_df <- (sapply(num_list, function(x) as.numeric(sin_vote == x)))
sin_df <- sin_df * x$weights
sin_vec <- colSums(sin_df)
return(sin_vec / sum(sin_vec))
}
# Create list with v_vecs from CSES utility dfs:
big_list_na_omit <- lapply(big_list, function(x) remove_nas(x))
sin_vote_list <- lapply(big_list_na_omit, function(x) sincere.vote.mat.from.U(x$U, rule = "AV"))
##################################################
## Project: Strategic Voting in RCV
## Script purpose: Classification
## Date: 17/12/2018
## Author:
##################################################
### DEPENDENCIES
library(here)
library()
# Load my own functions:
source(here("utils/functions.r"))
# Load pivotal probability functions:
av_piv_path <- here("utils/av_pivotal_probs_analytical_general_v2.r")
source(av_piv_path)
plur_piv_path <- here("utils/plurality_pivotal_probabilities_analytical.r")
source(plur_piv_path)
# To replicate Andy's function(s):
sim_appr2 <- here("utils", "general_iteration_simulation_approach.r")
source(sim_appr2)
sv_file <-  here("utils/sv.r")
source(sv_file)
# Load CSES data:
load(here("../output/cses_big_list_2.RData"))
remove_nas <- function(x){
mat <- cbind(x$U, x$weights)
mat <- na.omit(mat)
return(list(U = mat[, 1:3], weights = as.numeric(mat[, 4])))
}
create_v_vec <- function(x){
x$U <- x$U + runif(nrow(x$U) * ncol(x$U), min = 0, max = 0.001)
sin_vote <- as.numeric(apply(x$U, 1, function(x) sin_vote_scalar(x)))
num_list <- c(1:6)
sin_df <- (sapply(num_list, function(x) as.numeric(sin_vote == x)))
sin_df <- sin_df * x$weights
sin_vec <- colSums(sin_df)
return(sin_vec / sum(sin_vec))
}
# Create list with v_vecs from CSES utility dfs:
big_list_na_omit <- lapply(big_list, function(x) remove_nas(x))
sin_vote_list <- lapply(big_list_na_omit, function(x) sincere.vote.mat.from.U(x$U, rule = "AV"))
v_vec_list <- list()
for(i in 1:length(sin_vote_list)){
weights <- big_list_na_omit[[i]]$weights
v_vec <- ballot.props.from.vote.mat.and.weights(sin_vote_list[[i]], weights)
big_list_na_omit[[i]]$v_vec <- as.numeric(v_vec)
}
sapply(big_list_na_omit, function(x) x$v_vec)
t(sapply(big_list_na_omit, function(x) x$v_vec))
v_vec_df <- t(sapply(big_list_na_omit, function(x) x$v_vec))
# Create dataframe of v_vec cases
v_vec_df <- as.data.frame(t(sapply(big_list_na_omit, function(x) x$v_vec)))
names(v_vec_df) <- c("ABC", "ACB", "BAC", "BCA", "CAB", "CBA")
second_pref_df <- data.frame(mAB = v_vec_df[, 1] / (v_vec_df[, 1] + v_vec_df[, 2]), mBA = v_vec_df[, 3] / (v_vec_df[, 3] + v_vec_df[, 4]), mCB = v_vec_df[, 6] / (v_vec_df[, 5] + v_vec_df[, 6]))
install.packages("scatterplot3d") # Install
library("scatterplot3d") # load
scatterplot3d(second_pref_df$mAB, second_pref_df$mCB, second_pref_df$mBA)
library(car)
scatter3d(second_pref_df$mAB, second_pref_df$mCB, second_pref_df$mBA)
library(rgl)
install.packages("rgl")
library(rgl)
library(rgl)
scatter3d(second_pref_df$mAB, second_pref_df$mCB, second_pref_df$mBA)
scatter3d(second_pref_df$mAB, second_pref_df$mCB, second_pref_df$mBA)
scatter3d(second_pref_df$mAB, second_pref_df$mCB, second_pref_df$mBA)
library(plotly)
install.packages("plotly")
library(plotly)
plot_ly(second_pref_df, ~mAB, ~mBA, ~mCB)
plot_ly(second_pref_df, x = ~mAB, y = ~mBA, z = ~mCB)
names(big_list)[[39]]
names(big_list)[[145]]
apply(second_pref_df, 1, function(min(abs(0.5 - x))))
apply(second_pref_df, 1, function(x) min(abs(0.5 - x)))
neutral <- apply(second_pref_df, 1, function(x) x[which(x == min(abs(0.5 - x)))])
neutral
which(second_pref_df[1, ] == min(abs(0.5 - x)))
which(second_pref_df[1, ] == min(abs(0.5 - second_pref_df[1, ])))
min(abs(0.5 - second_pref_df[1, ]))
0.5 - second_pref_df[1, ]
neutral <- apply(second_pref_df, 1, function(x) min(abs(0.5 - x)))
strongest <- apply(second_pref_df, 1, function(x) max(abs(0.5 - x)))
plot(strongest, neutral)
?which.is.max
?which.max
neutral_loc <- apply(second_pref_df, 1, function(x) which.min(abs(0.5 - x)))
neutral_loc[[1]]
neutral_loc <- apply(second_pref_df, 1, function(x) as.numeric(which.min(abs(0.5 - x))))
strongest_loc <- apply(second_pref_df, 1, function(x) as.numeric(which.max(abs(0.5 - x))))
order <- data.frame(neutral_loc, strongest_loc)
neutral_loc <- apply(second_pref_df, 1, function(x) as.numeric(which.min(abs(0.5 - x))))
strongest_loc <- apply(second_pref_df, 1, function(x) as.numeric(which.max(abs(0.5 - x))))
order <- data.frame(neutral_loc, strongest_loc)
strongest_loc <- apply(second_pref_df, 1, function(x) unlist(which.max(abs(0.5 - x))))
neutral_loc <- apply(second_pref_df, 1, function(x) unlist(which.min(abs(0.5 - x))))
strongest_loc <- apply(second_pref_df, 1, function(x) unlist(as.numeric((which.max(abs(0.5 - x))))))
strongest_loc <- apply(second_pref_df, 1, function(x) as.numeric(unlist(which.max(abs(0.5 - x)))))
strongest_loc
unlist(strongest_loc)
strongest_loc <- apply(second_pref_df, 1, function(x) unlist(as.numeric(unlist(which.max(abs(0.5 - x))))))
order <- data.frame(unlist(neutral_loc), unlist(strongest_loc))
order$other_loc <- apply(order, 1, function(x) !(c(1, 2, 3) %in% x))
apply(order, 1, function(x) !(c(1, 2, 3) %in% x))
order$other_loc <- apply(order, 1, function(x) c(1, 2, 3)[!(c(1, 2, 3) %in% x)])
head(order)
for (i in 1:160){
print(second_pref_df[i, order[i, ]])
}
apply(order, 1, function(x) )
for (i in 1:160){
col_order <- as.numeric(order[i, ])
print(second_pref_df[i, col_order])
}
second_ordered_df <- matrix(NA, nrow = 160, col = 3)
second_ordered_df <- matrix(NA, nrow = 160, ncol = 3)
for (i in 1:160){
col_order <- as.numeric(order[i, ])
second_ordered_df[i, ] <- second_pref_df[i, col_order])
}
second_ordered_df <- matrix(NA, nrow = 160, ncol = 3)
for (i in 1:160){
col_order <- as.numeric(order[i, ])
second_ordered_df[i, ] <- second_pref_df[i, col_order]
}
?matrix
second_ordered_df <- matrix(NA, nrow = 160, ncol = 3)
for (i in 1:160){
col_order <- as.numeric(order[i, ])
second_ordered_df[i, ] <- as.numeric(second_pref_df[i, col_order])
}
head(second_ordered_df)
library(car)
scatter3d(second_ordered_df)
second_ordered_df <- as.data.frame(second_ordered_df)
scatter3d(second_ordered_df$V1, second_ordered_df$V2, second_ordered_df$V3)
scatter3d(second_ordered_df$V1, second_ordered_df$V2, second_ordered_df$V3)
library(rgl)
scatter3d(second_ordered_df$V1, second_ordered_df$V2, second_ordered_df$V3)
library(plotly)
plot_ly(second_ordered_df$V1, second_ordered_df$V2, second_ordered_df$V3)
plot_ly(second_ordered_df, x = ~V1, y = ~V2, z = ~V3)
plot_ly(second_ordered_df, x = ~V2, y = ~V3, z = ~V1)
plot(second_ordered_df$V2, second_ordered_df$V3)
which.max(second_ordered_df$V3)
second_pref_df[95, ]
plot(second_pref_df$mAB, second_pref_df$mCB)
plot(second_pref_df$mAB, second_pref_df$mBA)
plot(second_pref_df$mCB, second_pref_df$mBA)
plot(second_ordered_df$V2, second_ordered_df$V3)
second_ordered_df <- matrix(NA, nrow = 160, ncol = 3)
for (i in 1:160){
col_order <- as.numeric(order[i, ])
if(col_order[1] != 2){second_pref_df[i, 2] <- 1 - second_pref_df[i, 2]}
second_ordered_df[i, ] <- as.numeric(second_pref_df[i, col_order])
}
plot(second_ordered_df$V2, second_ordered_df$V3)
second_ordered_df <- as.data.frame(second_ordered_df)
plot(second_ordered_df$V2, second_ordered_df$V3)
plot_ly(second_ordered_df, x = ~V2, y = ~V3, z = ~V1)
plot(second_ordered_df$V2, second_ordered_df$V3)
plot(second_ordered_df$V1, second_ordered_df$V2)
plot(second_ordered_df$V1, second_ordered_df$V3)
plot3d(second_ordered_df$V2, second_ordered_df$V3, second_ordered_df$V1)
plot3d(second_ordered_df$V2, second_ordered_df$V3, second_ordered_df$V1)
install.packages("rgl")
library(rgl)
plot3d(second_ordered_df$V2, second_ordered_df$V3, second_ordered_df$V1)
options(rgl.printRglwidget = TRUE)
plot3d(second_ordered_df$V2, second_ordered_df$V3, second_ordered_df$V1)
plane <- lm("V1 ~ V2 + V3", second_ordered_df)
plane
planes3d(plane$coefficients["V2"], plane$coefficients["V3"], -1, plane$coefficients["(Intercept)"])
plot3d(second_ordered_df$V2, second_ordered_df$V3, second_ordered_df$V1)
plane <- lm("V1 ~ V2 + V3", second_ordered_df)
planes3d(plane$coefficients["V2"], plane$coefficients["V3"], -1, plane$coefficients["(Intercept)"], alpha = 0.3, front = "line")
planes3d(plane$coefficients["V2"], plane$coefficients["V3"], -1, plane$coefficients["(Intercept)"], alpha = 0.1, front = "line")
planes3d(plane$coefficients["V2"], plane$coefficients["V3"], -1, plane$coefficients["(Intercept)"], alpha = 0.1, front = "line")
ggplot(v_vec_df, aes(ABC)) +
geom_point()
# Load necessary libraries:
library(ggplot2)
library(reshape2)
library(dplyr)
library(purrr)
library(ggtern)
library(plotly)
ggplot(v_vec_df, aes(ABC)) +
geom_point()
ggplot(v_vec_df, aes(ABC)) +
geom_density()
ggplot(v_vec_df) +
geom_density(aes(ABC)) +
geom_density(aes(ACB), lty = "dotted")
ggplot(v_vec_df) +
geom_density(aes(BAC)) +
geom_density(aes(BCA), lty = "dotted")
ggplot(v_vec_df) +
geom_density(aes(CAB)) +
geom_density(aes(CBA), lty = "dotted")
?gather
v_vec_df_long <- gather(v_vec_df)
library(tidyr)
v_vec_df_long <- gather(v_vec_df)
ggplot(v_vec_df_long) +
geom_density(aes(value)) +
facet_wrap(~ key)
